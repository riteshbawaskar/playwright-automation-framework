#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');
const os = require('os');

console.log('üöÄ Setting up Test Automation Framework Environment...\n');

class EnvironmentSetup {
  constructor() {
    this.rootDir = path.resolve(__dirname, '..');
    this.errors = [];
    this.warnings = [];
  }

  async setup() {
    try {
      console.log('üìã Checking system requirements...');
      await this.checkSystemRequirements();
      
      console.log('üìÅ Creating directory structure...');
      await this.createDirectories();
      
      console.log('‚öôÔ∏è Setting up configuration files...');
      await this.setupConfigFiles();
      
      console.log('üîß Setting up development tools...');
      await this.setupDevelopmentTools();
      
      console.log('üé≠ Verifying Playwright installation...');
      await this.verifyPlaywright();
      
      console.log('üñ•Ô∏è Setting up Electron application...');
      await this.setupElectronApp();
      
      console.log('üìù Creating example files...');
      await this.createExampleFiles();
      
      this.printSummary();
      
    } catch (error) {
      console.error('‚ùå Setup failed:', error.message);
      process.exit(1);
    }
  }

  async checkSystemRequirements() {
    // Check Node.js version
    const nodeVersion = process.version;
    const requiredNodeVersion = '18.0.0';
    
    if (!this.isVersionSufficient(nodeVersion.substring(1), requiredNodeVersion)) {
      this.errors.push(`Node.js ${requiredNodeVersion} or higher required. Current: ${nodeVersion}`);
    } else {
      console.log(`  ‚úÖ Node.js ${nodeVersion}`);
    }
    
    // Check npm version
    try {
      const npmVersion = await this.executeCommand('npm', ['--version']);
      console.log(`  ‚úÖ npm ${npmVersion.stdout.trim()}`);
    } catch (error) {
      this.errors.push('npm not found');
    }
    
    // Check available memory
    const totalMemory = Math.round(os.totalmem() / 1024 / 1024 / 1024);
    if (totalMemory < 4) {
      this.warnings.push(`Low memory detected (${totalMemory}GB). 4GB+ recommended.`);
    } else {
      console.log(`  ‚úÖ Memory: ${totalMemory}GB`);
    }
    
    // Check platform
    console.log(`  ‚úÖ Platform: ${os.platform()} ${os.arch()}`);
    
    if (this.errors.length > 0) {
      throw new Error(`System requirements not met:\n${this.errors.join('\n')}`);
    }
  }

  async createDirectories() {
    const directories = [
      'output',
      'output/recordings',
      'output/page-objects',
      'output/tests',
      'output/reports',
      'output/screenshots',
      'output/videos',
      'test-results',
      'logs',
      'temp',
      'build-resources'
    ];
    
    for (const dir of directories) {
      const fullPath = path.join(this.rootDir, dir);
      if (!fs.existsSync(fullPath)) {
        fs.mkdirSync(fullPath, { recursive: true });
        console.log(`  ‚úÖ Created ${dir}/`);
      }
    }
  }

  async setupConfigFiles() {
    const configs = [
      {
        name: '.env.example',
        content: this.generateEnvExample()
      },
      {
        name: 'automation.config.js',
        content: this.generateAutomationConfig()
      },
      {
        name: 'playwright.config.js',
        content: this.generatePlaywrightConfig()
      },
      {
        name: '.eslintrc.js',
        content: this.generateESLintConfig()
      },
      {
        name: '.prettierrc',
        content: this.generatePrettierConfig()
      },
      {
        name: 'jest.config.js',
        content: this.generateJestConfig()
      }
    ];
    
    for (const config of configs) {
      const filePath = path.join(this.rootDir, config.name);
      if (!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, config.content);
        console.log(`  ‚úÖ Created ${config.name}`);
      } else {
        console.log(`  ‚ö†Ô∏è ${config.name} already exists, skipping`);
      }
    }
    
    // Create .env from .env.example if it doesn't exist
    const envPath = path.join(this.rootDir, '.env');
    if (!fs.existsSync(envPath)) {
      const envExamplePath = path.join(this.rootDir, '.env.example');
      if (fs.existsSync(envExamplePath)) {
        fs.copyFileSync(envExamplePath, envPath);
        console.log('  ‚úÖ Created .env from .env.example');
      }
    }
  }

  async setupDevelopmentTools() {
    // Setup Git hooks if in a Git repository
    if (fs.existsSync(path.join(this.rootDir, '.git'))) {
      try {
        await this.executeCommand('npx', ['husky', 'install'], { cwd: this.rootDir });
        console.log('  ‚úÖ Git hooks configured');
      } catch (error) {
        this.warnings.push('Failed to setup Git hooks');
      }
    }
    
    // Create VSCode settings
    const vscodeDir = path.join(this.rootDir, '.vscode');
    if (!fs.existsSync(vscodeDir)) {
      fs.mkdirSync(vscodeDir);
      
      const settings = {
        "editor.formatOnSave": true,
        "editor.codeActionsOnSave": {
          "source.fixAll.eslint": true
        },
        "typescript.preferences.importModuleSpecifier": "relative",
        "files.associations": {
          "*.hbs": "handlebars"
        }
      };
      
      fs.writeFileSync(
        path.join(vscodeDir, 'settings.json'),
        JSON.stringify(settings, null, 2)
      );
      console.log('  ‚úÖ VSCode settings created');
    }
  }

  async verifyPlaywright() {
    try {
      // Check if Playwright is installed
      await this.executeCommand('npx', ['playwright', '--version'], { cwd: this.rootDir });
      console.log('  ‚úÖ Playwright is installed');
      
      // Check browser installations
      const browsers = ['chromium', 'firefox', 'webkit'];
      for (const browser of browsers) {
        try {
          await this.executeCommand('npx', ['playwright', 'install', browser, '--dry-run'], { 
            cwd: this.rootDir,
            timeout: 10000 
          });
          console.log(`  ‚úÖ ${browser} browser ready`);
        } catch (error) {
          this.warnings.push(`${browser} browser may need installation`);
        }
      }
      
    } catch (error) {
      this.errors.push('Playwright verification failed');
      throw error;
    }
  }

  async setupElectronApp() {
    // Create icon files if they don't exist
    const iconDir = path.join(this.rootDir, 'build-resources');
    const iconFiles = ['icon.png', 'icon.icns', 'icon.ico', 'installer.ico', 'uninstaller.ico'];
    
    for (const iconFile of iconFiles) {
      const iconPath = path.join(iconDir, iconFile);
      if (!fs.existsSync(iconPath)) {
        // Create a placeholder icon file (this would normally be a real icon)
        fs.writeFileSync(iconPath, '# Placeholder icon file\n# Replace with actual icon');
        console.log(`  ‚ö†Ô∏è Created placeholder ${iconFile} (replace with actual icon)`);
      }
    }
    
    // Verify Electron
    try {
      await this.executeCommand('npx', ['electron', '--version'], { cwd: this.rootDir });
      console.log('  ‚úÖ Electron is ready');
    } catch (error) {
      this.warnings.push('Electron verification failed');
    }
  }

  async createExampleFiles() {
    // Create example test
    const exampleTestDir = path.join(this.rootDir, 'examples');
    if (!fs.existsSync(exampleTestDir)) {
      fs.mkdirSync(exampleTestDir, { recursive: true });
      
      const exampleTest = `import { test, expect } from '@playwright/test';

test('example test', async ({ page }) => {
  await page.goto('https://playwright.dev/');
  await expect(page).toHaveTitle(/Playwright/);
  
  // Click the Get Started button
  await page.getByRole('link', { name: 'Get started' }).click();
  await expect(page).toHaveURL(/.*intro/);
});`;
      
      fs.writeFileSync(path.join(exampleTestDir, 'example.spec.js'), exampleTest);
      console.log('  ‚úÖ Created example test');
    }
    
    // Create example page object
    const examplePageObject = `import { Page, Locator, expect } from '@playwright/test';

export class PlaywrightHomePage {
  constructor(page: Page) {
    this.page = page;
  }

  readonly getStartedLink = this.page.getByRole('link', { name: 'Get started' });
  readonly searchInput = this.page.getByPlaceholder('Search docs');
  readonly githubLink = this.page.getByRole('link', { name: 'GitHub' });

  async navigate(): Promise<void> {
    await this.page.goto('https://playwright.dev/');
    await expect(this.page).toHaveTitle(/Playwright/);
  }

  async clickGetStarted(): Promise<void> {
    await this.getStartedLink.click();
    await expect(this.page).toHaveURL(/.*intro/);
  }

  async search(query: string): Promise<void> {
    await this.searchInput.fill(query);
    await this.searchInput.press('Enter');
  }
}`;
    
    fs.writeFileSync(path.join(exampleTestDir, 'playwright-home.page.js'), examplePageObject);
    console.log('  ‚úÖ Created example page object');
  }

  printSummary() {
    console.log('\nüéâ Setup Complete!\n');
    
    console.log('üìã Summary:');
    console.log('  ‚úÖ Environment validated');
    console.log('  ‚úÖ Directories created');
    console.log('  ‚úÖ Configuration files setup');
    console.log('  ‚úÖ Development tools configured');
    console.log('  ‚úÖ Playwright verified');
    console.log('  ‚úÖ Electron application ready');
    console.log('  ‚úÖ Example files created');
    
    if (this.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è Warnings:');
      this.warnings.forEach(warning => console.log(`  ‚Ä¢ ${warning}`));
    }
    
    console.log('\nüöÄ Next Steps:');
    console.log('  1. Start the Electron app:    npm start');
    console.log('  2. Or use the CLI:            automation-cli interactive');
    console.log('  3. Run example test:          npm run test:e2e');
    console.log('  4. Read the documentation:    npm run docs');
    
    console.log('\nüí° Useful Commands:');
    console.log('  npm run dev                   # Start in development mode');
    console.log('  automation-cli record         # Record a new test');
    console.log('  automation-cli doctor         # Check system health');
    console.log('  npm run build                 # Build for distribution');
    
    console.log('\nüìñ Documentation: README.md');
    console.log('ü§ù Support: GitHub Issues\n');
  }

  // Configuration generators
  generateEnvExample() {
    return `# Test Automation Framework Environment Configuration
# Copy this file to .env and update values as needed

# Application Settings
NODE_ENV=development
DEBUG=automation:*
LOG_LEVEL=info

# Default URLs
BASE_URL=http://localhost:3000
API_BASE_URL=http://localhost:3001/api

# Browser Settings
DEFAULT_BROWSER=chromium
HEADLESS=false
VIEWPORT_WIDTH=1280
VIEWPORT_HEIGHT=720

# Test Settings
DEFAULT_TIMEOUT=30000
RETRY_COUNT=1
PARALLEL_WORKERS=2

# Recording Settings
RECORDING_OUTPUT_DIR=./output
GENERATE_PAGE_OBJECTS=true
OPTIMIZE_ACTIONS=true

# Reporting
REPORT_OUTPUT_DIR=./test-results
REPORT_FORMAT=html
OPEN_REPORT=true

# Electron Settings
ELECTRON_ENABLE_LOGGING=false
ELECTRON_DEV_TOOLS=false

# Security
DISABLE_WEB_SECURITY=false
IGNORE_CERTIFICATE_ERRORS=false

# Performance
MAX_MEMORY=4096
ENABLE_GPU=true`;
  }

  generateAutomationConfig() {
    return `/**
 * Test Automation Framework Configuration
 * Customize settings for recording, generation, and execution
 */

module.exports = {
  // Recording configuration
  recording: {
    browser: process.env.DEFAULT_BROWSER || 'chromium',
    headless: process.env.HEADLESS === 'true',
    viewport: {
      width: parseInt(process.env.VIEWPORT_WIDTH) || 1280,
      height: parseInt(process.env.VIEWPORT_HEIGHT) || 720
    },
    generatePageObjects: process.env.GENERATE_PAGE_OBJECTS !== 'false',
    optimizeActions: process.env.OPTIMIZE_ACTIONS !== 'false',
    outputDir: process.env.RECORDING_OUTPUT_DIR || './output',
    timeout: parseInt(process.env.DEFAULT_TIMEOUT) || 30000
  },

  // Code generation configuration
  codeGeneration: {
    template: 'typescript', // 'typescript' or 'javascript'
    framework: 'playwright', // 'playwright' or 'cypress'
    optimize: true,
    overwrite: false,
    generateUtilities: true,
    generateTests: true,
    generatePageObjects: true
  },

  // Test execution configuration
  testExecution: {
    browsers: ['chromium', 'firefox', 'webkit'],
    workers: parseInt(process.env.PARALLEL_WORKERS) || 2,
    timeout: parseInt(process.env.DEFAULT_TIMEOUT) || 30000,
    retries: parseInt(process.env.RETRY_COUNT) || 1,
    reporter: process.env.REPORT_FORMAT || 'html',
    outputDir: process.env.REPORT_OUTPUT_DIR || './test-results'
  },

  // Electron app configuration
  electron: {
    width: 1400,
    height: 900,
    minWidth: 1200,
    minHeight: 700,
    enableDevTools: process.env.NODE_ENV === 'development',
    enableLogging: process.env.ELECTRON_ENABLE_LOGGING === 'true'
  },

  // CLI configuration
  cli: {
    interactive: true,
    colorOutput: true,
    verbose: false,
    quiet: false
  }
};`;
  }

  generatePlaywrightConfig() {
    return `import { defineConfig, devices } from '@playwright/test';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

/**
 * Playwright Test Configuration
 * See https://playwright.dev/docs/test-configuration
 */
export default defineConfig({
  testDir: './tests',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : parseInt(process.env.RETRY_COUNT) || 0,
  workers: process.env.CI ? 1 : parseInt(process.env.PARALLEL_WORKERS) || undefined,
  
  reporter: [
    ['html', { outputFolder: 'test-results/html-report' }],
    ['json', { outputFile: 'test-results/results.json' }],
    ['junit', { outputFile: 'test-results/junit-results.xml' }],
    ['line']
  ],

  use: {
    baseURL: process.env.BASE_URL || 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
    actionTimeout: parseInt(process.env.DEFAULT_TIMEOUT) || 30000,
    navigationTimeout: parseInt(process.env.DEFAULT_TIMEOUT) || 30000,
    ignoreHTTPSErrors: process.env.IGNORE_CERTIFICATE_ERRORS === 'true'
  },

  projects: [
    {
      name: 'chromium',
      use: { 
        ...devices['Desktop Chrome'],
        viewport: {
          width: parseInt(process.env.VIEWPORT_WIDTH) || 1280,
          height: parseInt(process.env.VIEWPORT_HEIGHT) || 720
        }
      },
    },
    {
      name: 'firefox',
      use: { 
        ...devices['Desktop Firefox'],
        viewport: {
          width: parseInt(process.env.VIEWPORT_WIDTH) || 1280,
          height: parseInt(process.env.VIEWPORT_HEIGHT) || 720
        }
      },
    },
    {
      name: 'webkit',
      use: { 
        ...devices['Desktop Safari'],
        viewport: {
          width: parseInt(process.env.VIEWPORT_WIDTH) || 1280,
          height: parseInt(process.env.VIEWPORT_HEIGHT) || 720
        }
      },
    },
    {
      name: 'mobile-chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'mobile-safari',
      use: { ...devices['iPhone 12'] },
    },
  ],

  webServer: process.env.CI ? undefined : {
    command: 'npm run dev',
    url: process.env.BASE_URL || 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
    timeout: 120000
  },

  outputDir: 'test-results/',
  
  expect: {
    timeout: 5000
  }
});`;
  }

  generateESLintConfig() {
    return `module.exports = {
  env: {
    browser: true,
    es2021: true,
    node: true,
    jest: true
  },
  extends: [
    'eslint:recommended',
    '@typescript-eslint/recommended',
    'prettier'
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 'latest',
    sourceType: 'module'
  },
  plugins: [
    '@typescript-eslint',
    'jest'
  ],
  rules: {
    'no-console': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    'no-debugger': process.env.NODE_ENV === 'production' ? 'warn' : 'off',
    '@typescript-eslint/no-unused-vars': ['error', { 'argsIgnorePattern': '^_' }],
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    'prefer-const': 'error',
    'no-var': 'error'
  },
  overrides: [
    {
      files: ['**/*.test.js', '**/*.test.ts', '**/*.spec.js', '**/*.spec.ts'],
      env: {
        jest: true
      },
      rules: {
        'jest/no-disabled-tests': 'warn',
        'jest/no-focused-tests': 'error',
        'jest/no-identical-title': 'error',
        'jest/prefer-to-have-length': 'warn',
        'jest/valid-expect': 'error'
      }
    }
  ],
  ignorePatterns: [
    'dist/',
    'build/',
    'node_modules/',
    'test-results/',
    'coverage/'
  ]
};`;
  }

  generatePrettierConfig() {
    return `{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "quoteProps": "as-needed",
  "bracketSpacing": true,
  "arrowParens": "always",
  "endOfLine": "lf",
  "overrides": [
    {
      "files": "*.json",
      "options": {
        "printWidth": 80
      }
    },
    {
      "files": "*.md",
      "options": {
        "printWidth": 80,
        "proseWrap": "always"
      }
    }
  ]
}`;
  }

  generateJestConfig() {
    return `module.exports = {
  testEnvironment: 'node',
  roots: ['<rootDir>/tests', '<rootDir>/core', '<rootDir>/cli'],
  testMatch: [
    '**/__tests__/**/*.{js,ts}',
    '**/?(*.)+(spec|test).{js,ts}'
  ],
  transform: {
    '^.+\\\\.(ts|tsx): 'ts-jest',
    '^.+\\\\.(js|jsx): 'babel-jest'
  },
  collectCoverageFrom: [
    'core/**/*.{js,ts}',
    'cli/**/*.{js,ts}',
    '!**/node_modules/**',
    '!**/coverage/**',
    '!**/dist/**',
    '!**/*.d.ts'
  ],
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov', 'html'],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],
  testTimeout: 30000,
  verbose: true,
  clearMocks: true,
  resetMocks: true,
  restoreMocks: true
};`;
  }

  // Utility methods
  isVersionSufficient(current, required) {
    const currentParts = current.split('.').map(Number);
    const requiredParts = required.split('.').map(Number);
    
    for (let i = 0; i < Math.max(currentParts.length, requiredParts.length); i++) {
      const currentPart = currentParts[i] || 0;
      const requiredPart = requiredParts[i] || 0;
      
      if (currentPart > requiredPart) return true;
      if (currentPart < requiredPart) return false;
    }
    
    return true;
  }

  executeCommand(command, args, options = {}) {
    return new Promise((resolve, reject) => {
      const process = spawn(command, args, {
        stdio: 'pipe',
        ...options
      });

      let stdout = '';
      let stderr = '';

      process.stdout?.on('data', (data) => {
        stdout += data.toString();
      });

      process.stderr?.on('data', (data) => {
        stderr += data.toString();
      });

      const timeout = options.timeout || 30000;
      const timer = setTimeout(() => {
        process.kill('SIGTERM');
        reject(new Error(`Command timeout: ${command} ${args.join(' ')}`));
      }, timeout);

      process.on('close', (code) => {
        clearTimeout(timer);
        if (code === 0) {
          resolve({ stdout, stderr, code });
        } else {
          reject(new Error(`Command failed: ${command} ${args.join(' ')}\nExit code: ${code}\nStderr: ${stderr}`));
        }
      });

      process.on('error', (error) => {
        clearTimeout(timer);
        reject(error);
      });
    });
  }
}

// Run setup if called directly
if (require.main === module) {
  const setup = new EnvironmentSetup();
  setup.setup().catch((error) => {
    console.error('Setup failed:', error.message);
    process.exit(1);
  });
}

module.exports = EnvironmentSetup;